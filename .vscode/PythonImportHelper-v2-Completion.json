[
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "printSquare",
        "kind": 2,
        "importPath": "patterns.01_rectangular_star_pattern",
        "description": "patterns.01_rectangular_star_pattern",
        "peekOfCode": "def printSquare(n: int):\n    for i in range(n):\n        for j in range(n):\n            print(\"*\", end=\" \")\n        print()\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Square Star Pattern of size 5:\")\n    printSquare(5)",
        "detail": "patterns.01_rectangular_star_pattern",
        "documentation": {}
    },
    {
        "label": "nForest",
        "kind": 2,
        "importPath": "patterns.02_right-Angled_Triangle_pattern",
        "description": "patterns.02_right-Angled_Triangle_pattern",
        "peekOfCode": "def nForest(n: int):\n    for i in range(n):\n        for j in range(i + 1):\n            print(\"*\", end=\" \")\n        print()\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Right Angled Triangle Star Pattern of size 5:\")\n    nForest(5)",
        "detail": "patterns.02_right-Angled_Triangle_pattern",
        "documentation": {}
    },
    {
        "label": "nTriangle",
        "kind": 2,
        "importPath": "patterns.03_right-Angled_number_pyramid",
        "description": "patterns.03_right-Angled_number_pyramid",
        "peekOfCode": "def nTriangle(n):\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            print(j, end=\" \")\n        print()\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Right Angled Number Pyramid Pattern of size 5:\")\n    nTriangle(5)",
        "detail": "patterns.03_right-Angled_number_pyramid",
        "documentation": {}
    },
    {
        "label": "nTriangle",
        "kind": 2,
        "importPath": "patterns.04_right-Angled_number_pyramid",
        "description": "patterns.04_right-Angled_number_pyramid",
        "peekOfCode": "def nTriangle(n):\n    for i in range(n):\n        for j in range(i + 1):\n            print(i + 1, end=\" \")\n        print()\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Right Angled Number Pyramid Pattern of size 5:\")\n    nTriangle(5)",
        "detail": "patterns.04_right-Angled_number_pyramid",
        "documentation": {}
    },
    {
        "label": "seeding",
        "kind": 2,
        "importPath": "patterns.05_inverted_right_pyramid",
        "description": "patterns.05_inverted_right_pyramid",
        "peekOfCode": "def seeding(n):\n    for i in range(n, 0, -1):\n        for j in range(i):\n            print(i, end=\" \")\n        print()\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Inverted Right Angled Number Pyramid Pattern of size 5:\")\n    seeding(5)",
        "detail": "patterns.05_inverted_right_pyramid",
        "documentation": {}
    },
    {
        "label": "seeding",
        "kind": 2,
        "importPath": "patterns.06_inverted_right_pyramid",
        "description": "patterns.06_inverted_right_pyramid",
        "peekOfCode": "def seeding(n):\n    for i in range(n, 0, -1):\n        for j in range(i):\n            print(\"*\", end=\" \")\n        print()\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Inverted Right Angled Number Pyramid Pattern of size 5:\")\n    seeding(5)",
        "detail": "patterns.06_inverted_right_pyramid",
        "documentation": {}
    },
    {
        "label": "nStarTriangle",
        "kind": 2,
        "importPath": "patterns.07_star_pyramid",
        "description": "patterns.07_star_pyramid",
        "peekOfCode": "def nStarTriangle(n):\n    # Loop through each row\n    for i in range(n):\n        # Print leading spaces\n        for j in range(n - i - 1):\n            print(\" \", end=\" \")\n        # Print stars\n        for j in range(2 * i + 1):\n            print(\"*\", end=\" \")\n        # Move to the next line after each row",
        "detail": "patterns.07_star_pyramid",
        "documentation": {}
    },
    {
        "label": "nStarTriangle",
        "kind": 2,
        "importPath": "patterns.08_inverted_star_pyramid",
        "description": "patterns.08_inverted_star_pyramid",
        "peekOfCode": "def nStarTriangle(n: int) -> None:\n    \"\"\"\n    Print a star triangle of height n.\n    \"\"\"\n    for i in range(n, 0, -1):\n        # Print leading spaces\n        for j in range(n - i):\n            print(\" \", end=\" \")\n        # Print stars\n        for j in range(2 * i - 1):",
        "detail": "patterns.08_inverted_star_pyramid",
        "documentation": {}
    },
    {
        "label": "nStarDiamond",
        "kind": 2,
        "importPath": "patterns.09_diamond_star_pattern",
        "description": "patterns.09_diamond_star_pattern",
        "peekOfCode": "def nStarDiamond(n: int) -> None:\n    \"\"\"Prints a diamond star pattern of size n.\"\"\"\n    # Upper half\n    for i in range(n):\n        print(\" \" * (n - i - 1) + \"*\" * (2 * i + 1))\n    # Lower half\n    for i in range(n - 2, -1, -1):\n        print(\" \" * (n - i - 1) + \"*\" * (2 * i + 1))\n    print()\nif __name__ == \"__main__\":",
        "detail": "patterns.09_diamond_star_pattern",
        "documentation": {}
    },
    {
        "label": "half_diamond_star_pattern",
        "kind": 2,
        "importPath": "patterns.10_half_diamond_star_pattern",
        "description": "patterns.10_half_diamond_star_pattern",
        "peekOfCode": "def half_diamond_star_pattern(n):\n    # Print the upper half of the diamond\n    for i in range(n + 1):\n        print(\"*\" * i)\n    # Print the lower half of the diamond\n    for i in range(n - 1):\n        print(\"*\" * (n - i - 1))\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Half Diamond Star Pattern of size 5:\")",
        "detail": "patterns.10_half_diamond_star_pattern",
        "documentation": {}
    },
    {
        "label": "nBinaryTriangle",
        "kind": 2,
        "importPath": "patterns.11_Binary Number Triangle_pattern",
        "description": "patterns.11_Binary Number Triangle_pattern",
        "peekOfCode": "def nBinaryTriangle(n):\n    for i in range(n):\n        start = 1 if i % 2 == 0 else 0\n        row = []\n        for j in range(i + 1):\n            row.append(str(start))\n            start = 1 - start\n        print(\" \".join(row))\nif __name__ == \"__main__\":\n    nBinaryTriangle(5)",
        "detail": "patterns.11_Binary Number Triangle_pattern",
        "documentation": {}
    },
    {
        "label": "number_crown",
        "kind": 2,
        "importPath": "patterns.12_Number Crown Pattern",
        "description": "patterns.12_Number Crown Pattern",
        "peekOfCode": "def number_crown(n):\n    for i in range(1, n + 1):\n        # Left side numbers\n        left = [str(j) for j in range(1, i + 1)]\n        # Right side numbers\n        right = [str(j) for j in range(i, 0, -1)]\n        # Spaces between the crowns\n        space = \"  \" * (n - i) * 2\n        # Build the full row and print once\n        print(\" \".join(left) + space + \" \".join(right))",
        "detail": "patterns.12_Number Crown Pattern",
        "documentation": {}
    },
    {
        "label": "nNumberTriangle",
        "kind": 2,
        "importPath": "patterns.13_Increasing Number Triangle Pattern",
        "description": "patterns.13_Increasing Number Triangle Pattern",
        "peekOfCode": "def nNumberTriangle(n):\n    num = 1\n    for i in range(1, n + 1):\n        for j in range(i, i * 2):\n            print(num, end=\" \")\n            num += 1\n        print()\nif __name__ == \"__main__\":\n    nNumberTriangle(5)",
        "detail": "patterns.13_Increasing Number Triangle Pattern",
        "documentation": {}
    },
    {
        "label": "increasing_letter_triangle",
        "kind": 2,
        "importPath": "patterns.14_Increasing Letter Triangle Pattern",
        "description": "patterns.14_Increasing Letter Triangle Pattern",
        "peekOfCode": "def increasing_letter_triangle(n):\n    ch = ord(\"A\")\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            print(chr(ch), end=\" \")\n            ch += 1\n        ch = ord(\"A\")\n        print()\nif __name__ == \"__main__\":\n    increasing_letter_triangle(5)",
        "detail": "patterns.14_Increasing Letter Triangle Pattern",
        "documentation": {}
    },
    {
        "label": "reverse_latter_triangle",
        "kind": 2,
        "importPath": "patterns.15_Reverse Letter Triangle Pattern",
        "description": "patterns.15_Reverse Letter Triangle Pattern",
        "peekOfCode": "def reverse_latter_triangle(n):\n    ch = ord(\"A\")\n    for i in range(n + 1, 0, -1):\n        for j in range(1, i):\n            print(chr(ch), end=\" \")\n            ch += 1\n        ch = ord(\"A\")\n        print()\nif __name__ == \"__main__\":\n    reverse_latter_triangle(5)",
        "detail": "patterns.15_Reverse Letter Triangle Pattern",
        "documentation": {}
    },
    {
        "label": "alpha_ramp_pattern",
        "kind": 2,
        "importPath": "patterns.16_Alpha-Ramp Pattern",
        "description": "patterns.16_Alpha-Ramp Pattern",
        "peekOfCode": "def alpha_ramp_pattern(n):\n    ch = ord(\"A\")\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            print(chr(ch), end=\" \")\n        ch += 1\n        print()\nif __name__ == \"__main__\":\n    alpha_ramp_pattern(5)",
        "detail": "patterns.16_Alpha-Ramp Pattern",
        "documentation": {}
    },
    {
        "label": "alpha_hill",
        "kind": 2,
        "importPath": "patterns.17_Alpha-Hill Pattern",
        "description": "patterns.17_Alpha-Hill Pattern",
        "peekOfCode": "def alpha_hill(n):\n    ch = ord(\"A\")\n    for i in range(n):\n        print(\"  \" * (n - i), end=\"\")\n        for j in range(i + 1):\n            print(chr(ch), end=\" \")\n            ch += 1\n        ch -= 1\n        for j in range(i, 0, -1):\n            ch -= 1",
        "detail": "patterns.17_Alpha-Hill Pattern",
        "documentation": {}
    },
    {
        "label": "alpha_triangle",
        "kind": 2,
        "importPath": "patterns.18_Alpha-Triangle Pattern",
        "description": "patterns.18_Alpha-Triangle Pattern",
        "peekOfCode": "def alpha_triangle(n):\n    ch = ord(\"A\") + n - 1\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            print(chr(ch), end=\" \")\n            ch -= 1\n        ch = ord(\"A\") + n - 1\n        print()\nif __name__ == \"__main__\":\n    alpha_triangle(5)",
        "detail": "patterns.18_Alpha-Triangle Pattern",
        "documentation": {}
    },
    {
        "label": "symmetric_void_pattern",
        "kind": 2,
        "importPath": "patterns.19_Symmetric-Void Pattern",
        "description": "patterns.19_Symmetric-Void Pattern",
        "peekOfCode": "def symmetric_void_pattern(n):\n    for i in range(n, 0, -1):\n        star = \"*\" * i\n        space = \"  \" * (n - i) if n - i != 0 else \"\"\n        print(f\"{star}{space}{star}\")\n    for i in range(1, n + 1):\n        star = \"*\" * i\n        space = \"  \" * (n - i) if n - i != 0 else \"\"\n        print(f\"{star}{space}{star}\")\nif __name__ == \"__main__\":",
        "detail": "patterns.19_Symmetric-Void Pattern",
        "documentation": {}
    },
    {
        "label": "symmetric_butterfly_pattern",
        "kind": 2,
        "importPath": "patterns.20_Symmetric-Butterfly Pattern",
        "description": "patterns.20_Symmetric-Butterfly Pattern",
        "peekOfCode": "def symmetric_butterfly_pattern(n):\n    for i in range(1, n + 1):\n        star = \"*\" * i\n        space = \"  \" * (n - i) if n - i != 0 else \"\"\n        print(f\"{star}{space}{star}\")\n    for i in range(n - 1, 0, -1):\n        star = \"*\" * i\n        space = \"  \" * (n - i) if n - i != 0 else \"\"\n        print(f\"{star}{space}{star}\")\nif __name__ == \"__main__\":",
        "detail": "patterns.20_Symmetric-Butterfly Pattern",
        "documentation": {}
    },
    {
        "label": "hollow_rectangle_pattern",
        "kind": 2,
        "importPath": "patterns.21_Hollow Rectangle Pattern",
        "description": "patterns.21_Hollow Rectangle Pattern",
        "peekOfCode": "def hollow_rectangle_pattern(n):\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or i == n - 1 or j == 0 or j == n - 1:\n                print(\"*\", end=\"\")\n            else:\n                print(\" \", end=\"\")\n        print()\nif __name__ == \"__main__\":\n    hollow_rectangle_pattern(5)",
        "detail": "patterns.21_Hollow Rectangle Pattern",
        "documentation": {}
    },
    {
        "label": "number_patter",
        "kind": 2,
        "importPath": "patterns.22_The Number Pattern",
        "description": "patterns.22_The Number Pattern",
        "peekOfCode": "def number_patter(n):\n    size = 2 * n - 1\n    for i in range(size):\n        for j in range(size):\n            val = n - min(i, j, size - 1 - i, size - 1 - j)\n            print(val, end=\" \")\n        print()\nif __name__ == \"__main__\":\n    number_patter(5)",
        "detail": "patterns.22_The Number Pattern",
        "documentation": {}
    },
    {
        "label": "two_pointer",
        "kind": 2,
        "importPath": "python.001_two_sum",
        "description": "python.001_two_sum",
        "peekOfCode": "def two_pointer(nums, target):\n    \"\"\"\n    Brute-force approach using nested loops.\n    Finds two numbers in nums that sum up to the target.\n    Time Complexity: O(n^2) - Due to the nested loops iterating over all pairs.\n    Space Complexity: O(1) - No extra space used apart from input storage.\n    :param nums: List[int] - Input list of numbers.\n    :param target: int - Target sum.\n    :return: List[int] - Indices of two numbers that sum up to the target.\n    \"\"\"",
        "detail": "python.001_two_sum",
        "documentation": {}
    },
    {
        "label": "using_hash_table",
        "kind": 2,
        "importPath": "python.001_two_sum",
        "description": "python.001_two_sum",
        "peekOfCode": "def using_hash_table(nums, target):\n    \"\"\"\n    Optimized approach using a hash table (dictionary).\n    Finds two numbers in nums that sum up to the target in linear time.\n    Time Complexity: O(n) - We traverse the list once.\n    Space Complexity: O(n) - We store elements in a dictionary.\n    :param nums: List[int] - Input list of numbers.\n    :param target: int - Target sum.\n    :return: List[int] - Indices of two numbers that sum up to the target.\n    \"\"\"",
        "detail": "python.001_two_sum",
        "documentation": {}
    },
    {
        "label": "valid_parentheses",
        "kind": 2,
        "importPath": "python.002_valid_parentheses",
        "description": "python.002_valid_parentheses",
        "peekOfCode": "def valid_parentheses(string: str):\n    stack = []\n    bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in string:\n        if char in bracket_map:\n            if stack and stack[-1] == bracket_map[char]:\n                stack.pop()\n            else:\n                return False\n        else:",
        "detail": "python.002_valid_parentheses",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "python.003_merge_two_sorted_lists",
        "description": "python.003_merge_two_sorted_lists",
        "peekOfCode": "class Solution:\n    def mergeTwoLists(\n        self, list1: Optional[ListNode], list2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        k = ListNode()\n        i = k\n        while list1 and list2:\n            if list1.val < list2.val:\n                i.next = list1\n                list1 = list1.next",
        "detail": "python.003_merge_two_sorted_lists",
        "documentation": {}
    },
    {
        "label": "climbStairs",
        "kind": 2,
        "importPath": "python.004_climbing_stairs",
        "description": "python.004_climbing_stairs",
        "peekOfCode": "def climbStairs(n: int) -> int:\n    if n <= 1 or n >= 45:\n        return\n    first, second = 1, 2\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n    return second\nif __name__ == \"__main__\":\n    climbStairs(4)",
        "detail": "python.004_climbing_stairs",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "python.005_same_tree",
        "description": "python.005_same_tree",
        "peekOfCode": "class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
        "detail": "python.005_same_tree",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "python.006_maximum_depth_of_binary_tree",
        "description": "python.006_maximum_depth_of_binary_tree",
        "peekOfCode": "class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        left_max = self.maxDepth(root.left)\n        right_max = self.maxDepth(root.right)\n        return 1 + max(left_max, right_max)",
        "detail": "python.006_maximum_depth_of_binary_tree",
        "documentation": {}
    },
    {
        "label": "gcdOfStrings",
        "kind": 2,
        "importPath": "python.GCD_string",
        "description": "python.GCD_string",
        "peekOfCode": "def gcdOfStrings(str1: str, str2: str):\n    # Get the lengths of str1 and str2 and store them in l1 and l2 for later use.\n    # Example: str1 = \"ABCABC\" -> l1 = 6, str2 = \"ABC\" -> l2 = 3\n    l1, l2 = len(str1), len(str2)\n    # Loop over possible lengths (i) from the smaller string's length down to 1.\n    # We start with the max possible length to find the *greatest* common divisor first.\n    # min(l1, l2) ensures we don’t exceed the shorter string’s length.\n    for i in range(min(l1, l2), 0, -1):\n        # Check if i divides both l1 and l2 evenly (no remainder).\n        # This is like finding a common factor in numbers; the substring length must work for both.",
        "detail": "python.GCD_string",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "python.Kids_With_the_Greatest_Number_of_Candies",
        "description": "python.Kids_With_the_Greatest_Number_of_Candies",
        "peekOfCode": "def solution(candies: list[int], extraCandies: int) -> list[bool]:\n    max_candy = max(candies)\n    return [(candy + extraCandies >= max_candy) for candy in candies]\nif __name__ == \"__main__\":\n    candies = [2, 3, 5, 1, 3]\n    extraCandies = 3\n    print(solution(candies, extraCandies))",
        "detail": "python.Kids_With_the_Greatest_Number_of_Candies",
        "documentation": {}
    },
    {
        "label": "find_max_average",
        "kind": 2,
        "importPath": "python.Maximum Average Subarray I",
        "description": "python.Maximum Average Subarray I",
        "peekOfCode": "def find_max_average(nums, k):\n    # Step 1: Calculate the sum of the first window of size k\n    window_sum = sum(nums[:k])  # Initial window: nums[0] to nums[k-1]\n    max_sum = window_sum  # Store the maximum sum found so far\n    # Step 2: Slide the window through the array from index k to the end\n    for i in range(k, len(nums)):\n        # Remove the element that is going out of the window (nums[i - k])\n        # Add the new element that is coming into the window (nums[i])\n        window_sum += nums[i] - nums[i - k]\n        # Update max_sum if the new window_sum is greater",
        "detail": "python.Maximum Average Subarray I",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "python.add_two_number",
        "description": "python.add_two_number",
        "peekOfCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        \"\"\"\n        Initializes a node with a given value and a pointer to the next node.\n        :param val: Integer value of the node.\n        :param next: Pointer to the next ListNode in the linked list.\n        \"\"\"\n        self.val = val\n        self.next = next\n    def __str__(self):",
        "detail": "python.add_two_number",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "python.add_two_number",
        "description": "python.add_two_number",
        "peekOfCode": "class Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        \"\"\"\n        Adds two numbers represented as linked lists and returns the sum as a new linked list.\n        Each node contains a single digit, and digits are stored in reverse order.\n        :param l1: Head of the first linked list.\n        :param l2: Head of the second linked list.\n        :return: Head of the resulting linked list representing the sum.",
        "detail": "python.add_two_number",
        "documentation": {}
    },
    {
        "label": "length_of_longest_substring",
        "kind": 2,
        "importPath": "python.longest_Substring_Without_Repeating_Characters",
        "description": "python.longest_Substring_Without_Repeating_Characters",
        "peekOfCode": "def length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    Finds the length of the longest substring without repeating characters.\n    Uses the sliding window technique with a set to efficiently track characters.\n    Time Complexity: O(n) - Each character is processed at most twice (once added and once removed).\n    Space Complexity: O(min(n, 26)) - Stores unique characters, at most 26 if only lowercase English letters are used.\n    :param s: Input string\n    :return: Length of the longest substring without repeating characters\n    \"\"\"\n    char_set = set()  # Set to store unique characters in the current window",
        "detail": "python.longest_Substring_Without_Repeating_Characters",
        "documentation": {}
    },
    {
        "label": "longest_prefix",
        "kind": 2,
        "importPath": "python.longest_common_prefix",
        "description": "python.longest_common_prefix",
        "peekOfCode": "def longest_prefix(strs: list[str]):\n    strs.sort()\n    prefix = \"\"\n    for i in range(len(strs[0])):\n        if strs[0][i] != strs[-1][i]:\n            return prefix\n        prefix += strs[0][i]\n    return prefix\nif __name__ == \"__main__\":\n    strs = [\"flower\", \"flow\", \"flight\"]",
        "detail": "python.longest_common_prefix",
        "documentation": {}
    },
    {
        "label": "mergeAlternately",
        "kind": 2,
        "importPath": "python.merge_string_alternately",
        "description": "python.merge_string_alternately",
        "peekOfCode": "def mergeAlternately(word1: str, word2: str) -> str:\n    ans = \"\"\n    loop_obj = word1 if len(word1) > len(word2) else word2\n    for i in range(len(loop_obj)):\n        if i < len(word1):\n            ans += word1[i]\n        if i < len(word2):\n            ans += word2[i]\n    return ans\nif __name__ == \"__main__\":",
        "detail": "python.merge_string_alternately",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "kind": 2,
        "importPath": "python.palindrome_number",
        "description": "python.palindrome_number",
        "peekOfCode": "def is_palindrome(number):\n    original_number = number\n    compare_number = 0\n    while number > 0:\n        end_number = number % 10\n        compare_number = compare_number * 10 + end_number\n        number //= 10\n    return original_number == compare_number\nif __name__ == \"__main__\":\n    result = is_palindrome(121)",
        "detail": "python.palindrome_number",
        "documentation": {}
    },
    {
        "label": "reverse_integer",
        "kind": 2,
        "importPath": "python.reverse_integer",
        "description": "python.reverse_integer",
        "peekOfCode": "def reverse_integer(x: int):\n    \"\"\"\n    Time Complexity:\n    - O(log(x)), where `x` is the absolute value of the input integer.\n    - Each iteration processes one digit, and the number of digits in `x` is logarithmic in base 10, so the time complexity is proportional to the number of digits.\n    Space Complexity:\n    - O(1) (constant space).\n    - We only use a few variables (`reversed_x`, `sign`, `m`) to store intermediate values, which does not depend on the size of the input number.\n    \"\"\"\n    # Constants for the minimum and maximum 32-bit integer values",
        "detail": "python.reverse_integer",
        "documentation": {}
    },
    {
        "label": "roman_to_integer",
        "kind": 2,
        "importPath": "python.roman_to_integer",
        "description": "python.roman_to_integer",
        "peekOfCode": "def roman_to_integer(roman: str):\n    roman_numbers = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }",
        "detail": "python.roman_to_integer",
        "documentation": {}
    },
    {
        "label": "rotate_array_brute_force",
        "kind": 2,
        "importPath": "python.rotate_array",
        "description": "python.rotate_array",
        "peekOfCode": "def rotate_array_brute_force(nums: list, k: int):\n    \"\"\"\n    Brute-force approach: Rotate the array one step at a time.\n    Time Complexity: O(k * n) - Very slow for large n and k.\n    Space Complexity: O(1) - Modifies the array in place.\n    \"\"\"\n    k = k % len(nums)  # Handle cases where k > len(nums)\n    for _ in range(k):\n        last_element = nums.pop()  # Remove last element\n        nums.insert(0, last_element)  # Insert it at the beginning (O(n) operation)",
        "detail": "python.rotate_array",
        "documentation": {}
    },
    {
        "label": "rotate_array",
        "kind": 2,
        "importPath": "python.rotate_array",
        "description": "python.rotate_array",
        "peekOfCode": "def rotate_array(nums: list, k: int):\n    \"\"\"\n    Optimized approach: Rotate the array using slicing.\n    Time Complexity: O(n) - Only two slicing operations.\n    Space Complexity: O(n) - Creates a new list before modifying nums.\n    \"\"\"\n    k = k % len(nums)  # Handle cases where k > len(nums)\n    nums[:] = nums[-k:] + nums[:-k]  # Move last k elements to the front\nif __name__ == \"__main__\":\n    # Brute-force method",
        "detail": "python.rotate_array",
        "documentation": {}
    }
]